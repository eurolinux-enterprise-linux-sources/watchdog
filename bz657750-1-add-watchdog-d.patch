diff -ur watchdog-5.6.orig/ChangeLog watchdog-5.6/ChangeLog
--- watchdog-5.6.orig/ChangeLog	2009-03-22 13:33:38.000000000 +0000
+++ watchdog-5.6/ChangeLog	2013-08-06 16:06:31.592256107 +0100
@@ -447,6 +447,10 @@
 	- Expanded that patch to work for more tests.
 	- Released version 5.5
 
+Fri, 03 Dec 2010 17:36:00 -0400
+
+	- Added /etc/watchdog.d capability.
+
 Tue,  3 Mar 2009 14:59:55 +0100
 
 	- Added patch by Enrique Zanardi <ezanardi@atlantux.com> to
diff -ur watchdog-5.6.orig/configure.in watchdog-5.6/configure.in
--- watchdog-5.6.orig/configure.in	2009-03-12 14:42:25.000000000 +0000
+++ watchdog-5.6/configure.in	2013-08-06 16:06:02.412250315 +0100
@@ -122,6 +122,20 @@
   AC_MSG_RESULT(80)
 ])
 
+AC_MSG_CHECKING(for test binary directory)
+AC_ARG_WITH(test-bin-path,
+[  --with-test-bin-path=directory
+			  path to test binaries (default /etc/watchdog.d)],[
+  AC_DEFINE_UNQUOTED(TESTBIN_PATH, "$withval", "path to test binaries")
+  TESTBIN_PATH="$withval"
+  AC_MSG_RESULT($withval)
+],[
+  TESTBIN_PATH="/etc/watchdog.d"
+  AC_DEFINE_UNQUOTED(TESTBIN_PATH, "$TESTBIN_PATH", "path to test binaries")
+  AC_MSG_RESULT($TESTBIN_PATH)
+])
+AC_SUBST(TESTBIN_PATH)
+
 AC_MSG_CHECKING(for pid filename)
 AC_ARG_WITH(pidfile,
 [  --with-pidfile=filename name of pid file (default /var/run/watchdog.pid)],[
diff -ur watchdog-5.6.orig/src/test_binary.c watchdog-5.6/src/test_binary.c
--- watchdog-5.6.orig/src/test_binary.c	2009-03-13 12:49:58.000000000 +0000
+++ watchdog-5.6/src/test_binary.c	2013-08-06 16:06:02.414250491 +0100
@@ -9,6 +9,7 @@
 #include <stdlib.h>
 #include <sys/wait.h>
 #include <time.h>
+#include <linux/limits.h>
 
 #include "extern.h"
 #include "watch_err.h"
@@ -19,6 +20,7 @@
 
 struct process
 {
+    char proc_name[PATH_MAX];
     pid_t pid;
     time_t time;
     struct process *next;
@@ -26,9 +28,11 @@
 
 static struct process *process_head = NULL;
 
-static void add_process (pid_t pid)
+static void add_process (const char *name, pid_t pid)
 {
     struct process *node = (struct process *) malloc (sizeof (struct process));
+
+    snprintf(node->proc_name, sizeof(node->proc_name), "%s", name);
     node->pid = pid;
     node->time = time (NULL);
     node->next = process_head;
@@ -54,14 +58,20 @@
 }
 
 /* See if any test processes have exceeded the timeout */
-static int check_processes (time_t timeout)
+static int check_processes (const char *name, time_t timeout)
 {
     struct process *current;
     time_t now = time (NULL);
     
     current = process_head;
     while (current != NULL) {
+<<<<<<< HEAD
         if (now - current->time > timeout)
+=======
+        if (!strcmp(current->proc_name, name) &&
+	      now - current->time > timeout) {
+            remove_process (current->pid);
+>>>>>>> 0fc6d00... This patch allows zero or more scripts/programs to be placed
             return (ETOOLONG);
         current = current->next;
     }
@@ -74,8 +84,11 @@
     pid_t child_pid;
     int result, res = 0;
 
+    if (tbinary == NULL)
+        return ENOERR;
+
     if (timeout > 0)
-	    res = check_processes(timeout);
+	    res = check_processes(tbinary, timeout);
     if (res == ETOOLONG) {
 #if USE_SYSLOG
         syslog(LOG_ERR, "test-binary %s exceeded time limit %ld", tbinary, timeout);
@@ -120,14 +133,14 @@
 	int ret, err;
 
 	/* fork was okay, add child to process list */
-	add_process(child_pid);
+	add_process(tbinary, child_pid);
 
 	/* wait for child(s) to stop */
 	/* but only after a short sleep */
 	sleep(tint >> 1);
 
 	do {
-	    ret = waitpid(-1, &result, WNOHANG);
+	    ret = waitpid(child_pid, &result, WNOHANG);
 	    err = errno;
         if (ret > 0)
             remove_process(ret);
diff -ur watchdog-5.6.orig/src/watchdog.c watchdog-5.6/src/watchdog.c
--- watchdog-5.6.orig/src/watchdog.c	2009-03-22 12:52:24.000000000 +0000
+++ watchdog-5.6/src/watchdog.c	2013-08-06 16:06:02.416250662 +0100
@@ -32,6 +32,8 @@
 #if !defined(__GLIBC__)		/* __GLIBC__ */
 extern char *basename(const char *);
 #endif				/* __GLIBC__ */
+#include <libgen.h>
+#include <dirent.h>
 
 #include <unistd.h>
 
@@ -208,6 +210,17 @@
     wd_action(keep_alive(), rbinary, NULL);
 }
 
+#ifdef TESTBIN_PATH
+static void do_check2(int res, char *r_specific, char *r_global, char *name)
+{
+    wd_action(res, r_specific, name);
+    wd_action(keep_alive(), r_global, NULL);
+}
+
+/* Self-repairing binaries list */
+struct list *tr_bin = NULL;
+#endif
+
 struct list *file = NULL, *target = NULL, *pidfile = NULL, *iface = NULL;
 char *tbinary, *rbinary, *admin;
 
@@ -432,6 +445,58 @@
     }
 }
 
+#ifdef TESTBIN_PATH
+static void add_test_binaries(const char *path)
+{
+    DIR *d;
+    struct dirent dentry;
+    struct dirent *rdret;
+    struct stat sb;
+    int ret;
+    char fname[PATH_MAX];
+    char *fdup;
+
+    ret = stat(path, &sb);
+    if (ret < 0)
+	return;
+    if (!S_ISDIR(sb.st_mode))
+	return;
+
+    d = opendir(path);
+    if (!d)
+	return;
+    do {
+	ret = readdir_r(d, &dentry, &rdret);
+	if (ret)
+	    break;
+	if (rdret == NULL)
+	    break;
+
+	ret = snprintf(fname, sizeof(fname), "%s/%s",
+		       path, dentry.d_name);
+	if (ret >= sizeof(fname))
+	    continue;
+	ret = stat(fname, &sb);
+	if (ret < 0)
+	    continue;
+	if (!S_ISREG(sb.st_mode))
+	    continue;
+	if (!(sb.st_mode & S_IXUSR))
+	    continue;
+	if (!(sb.st_mode & S_IRUSR))
+	    continue;
+
+	fdup = strdup(fname);
+	if (!fdup)
+	    continue;
+
+	syslog(LOG_DEBUG, "adding %s to list of auto-repair binaries",
+	       fdup);
+	add_list(&tr_bin, fdup);
+    } while (1);
+}
+#endif
+
 static void old_option(int c, char *filename)
 {
     fprintf(stderr, "Option -%c is no longer valid, please specify it in %s.\n", c, filename);
@@ -519,6 +584,9 @@
     }
 
     read_config(filename, progname);
+#ifdef TESTBIN_PATH
+    add_test_binaries(TESTBIN_PATH);
+#endif
 
     if (tint < 0)
 	usage();
@@ -859,6 +927,12 @@
 	/* in user mode execute the given binary or just test fork() call */
 	do_check(check_bin(tbinary, timeout), rbinary, NULL);
 
+#ifdef TESTBIN_PATH
+	/* test/repair binaries in the watchdog.d directory */
+	for (act = tr_bin; act != NULL; act = act->next)
+	    do_check2(check_bin(act->name, timeout), act->name, rbinary, NULL);
+#endif
+
 	/* finally sleep some seconds */
 	sleep((tint >> 1) + (tint % 2)); /* this should make watchdog sleep tint seconds alltogther */
 	/* sleep(tint); */
